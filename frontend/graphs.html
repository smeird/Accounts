<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Graphs</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://unpkg.com/tabulator-tables@6.3.0/dist/css/tabulator_simple.min.css">
</head>
<body class="bg-gradient-to-b from-indigo-50 to-white font-sans">
    <div class="flex min-h-screen">
        <nav id="menu" class="w-64 flex-shrink-0 bg-white border-r p-6"></nav>
        <main class="flex-1 min-w-0 overflow-x-auto p-6 space-y-8">
            <h1 class="text-2xl font-semibold text-indigo-700">Graphs</h1>
            <p class="mb-4">Explore a collection of charts that illustrate your income and spending patterns. Choose a year to see how your finances evolve and compare categories or tags visually.</p>
            <label for="year-select" class="block">Year:
                <select id="year-select" class="border p-2 rounded w-full"></select>
            </label>
            <div class="bg-white p-6 rounded shadow"><div id="income-sunburst-chart" style="height:600px"></div></div>
            <div class="bg-white p-6 rounded shadow"><div id="outgoing-sunburst-chart" style="height:600px"></div></div>
            <div class="bg-white p-6 rounded shadow"><div id="monthly-chart" style="height:400px"></div></div>
            <div class="bg-white p-6 rounded shadow"><div id="cumulative-chart" style="height:400px"></div></div>
            <div class="bg-white p-6 rounded shadow"><div id="pie-chart" style="height:400px"></div></div>
            <div class="bg-white p-6 rounded shadow"><div id="tag-chart" style="height:400px"></div></div>
            <div class="bg-white p-6 rounded shadow"><div id="scatter-chart" style="height:400px"></div></div>
            <div class="bg-white p-6 rounded shadow space-y-4">
                <h2 class="text-xl font-semibold">Segment Totals</h2>
                <div id="segment-table"></div>
                <div id="segment-chart" style="height:400px"></div>
            </div>
        </main>
    </div>

    <script src="js/menu.js"></script>
    <script src="https://code.highcharts.com/highcharts.js"></script>
    <script src="https://code.highcharts.com/highcharts-3d.js"></script>
    <script src="https://code.highcharts.com/modules/sunburst.js"></script>

    <script src="https://code.highcharts.com/modules/accessibility.js"></script>

    <script src="https://unpkg.com/tabulator-tables@6.3.0/dist/js/tabulator.min.js"></script>
    <script src="js/tabulator-tailwind.js"></script>
    <script>

    // Retrieve data for the chosen year and draw charts with 3D bars where applicable
    const gradientColors = ['#4B0082', '#40826D', '#50C878', '#AAF0D1'];

    function loadYear(year){
        Promise.all([
            fetch('../php_backend/public/dashboard.php?year=' + year).then(r => r.json()),
            fetch('../php_backend/public/yearly_dashboard.php?year=' + year).then(r => r.json()),
            fetch('../php_backend/public/categories.php').then(r => r.json())
        ]).then(([monthly, yearly, categories]) => {
            const months = monthly.map(m => new Date(0, m.month - 1).toLocaleString('default', { month: 'short' }));
            const totals = monthly.map(m => parseFloat(m.spent));
            const categorySeries = yearly.categories.map(c => ({
                name: c.name,
                data: months.map((_, i) => parseFloat(c[String(i + 1)]) || 0)
            }));

            Highcharts.chart('monthly-chart', {
                chart: {
                    type: 'column',

                    options3d: { enabled: true, alpha: 0, beta: 0, depth: 50 }

                },
                title: { text: 'Monthly Spending by Category' },
                xAxis: { categories: months },
                yAxis: {
                    title: { text: 'Amount (£)' },
                    labels: { formatter: function(){ return '£' + Highcharts.numberFormat(this.value, 2); } }
                },
                tooltip: { pointFormatter: function(){ return '£' + Highcharts.numberFormat(this.y, 2); } },
                plotOptions: { column: { stacking: 'normal', depth: 40 } },
                series: categorySeries
            });

            const cumulative = totals.reduce((acc, val) => {
                const last = acc.length ? acc[acc.length - 1] : 0;
                acc.push(last + val);
                return acc;
            }, []);
            const categoryCumulative = categorySeries.map(cs => ({
                name: cs.name,
                data: cs.data.reduce((acc, val) => {
                    const last = acc.length ? acc[acc.length - 1] : 0;
                    acc.push(last + val);
                    return acc;
                }, [])
            }));
            Highcharts.chart('cumulative-chart', {
                chart: {
                    type: 'column',

                    options3d: { enabled: true, alpha: 0, beta: 0, depth: 50 }

                },
                title: { text: 'Cumulative Spending by Category' },
                xAxis: { categories: months },
                yAxis: {
                    title: { text: 'Amount (£)' },
                    labels: { formatter: function(){ return '£' + Highcharts.numberFormat(this.value, 2); } }
                },
                tooltip: { pointFormatter: function(){ return '£' + Highcharts.numberFormat(this.y, 2); } },
                plotOptions: { column: { stacking: 'normal', depth: 40 } },
                series: categoryCumulative
            });

            const catData = yearly.categories.map(c => ({ name: c.name, y: parseFloat(c.total) }));
            Highcharts.chart('pie-chart', {
                chart: {

                    type: 'pie'

                },
                title: { text: 'Category Breakdown' },
                tooltip: { pointFormatter: function(){ return '£' + Highcharts.numberFormat(this.y, 2); } },
                plotOptions: { pie: { depth: 35 } },
                series: [{ name: 'Categories', data: catData }]
            });

            const tagNames = yearly.tags.map(t => t.name);
            const tagTotals = yearly.tags.map(t => parseFloat(t.total));
            Highcharts.chart('tag-chart', {
                colors: gradientColors,
                chart: {
                    type: 'bar',

                    options3d: { enabled: true, alpha: 0, beta: 0, depth: 50 }

                },
                title: { text: 'Tag Totals' },
                xAxis: { categories: tagNames },
                yAxis: {
                    title: { text: 'Amount (£)' },
                    labels: { formatter: function(){ return '£' + Highcharts.numberFormat(this.value, 2); } }
                },
                tooltip: { pointFormatter: function(){ return '£' + Highcharts.numberFormat(this.y, 2); } },
                plotOptions: { bar: { depth: 40 } },
                series: [{ name: 'Total', data: tagTotals, colorByPoint: true }]
            });

            Highcharts.chart('scatter-chart', {
                colors: gradientColors,
                chart: {

                    type: 'scatter'

                },
                title: { text: 'Monthly Spending Scatter' },
                xAxis: { categories: months, title: { text: 'Month' } },
                yAxis: {
                    title: { text: 'Amount (£)' },
                    labels: { formatter: function(){ return '£' + Highcharts.numberFormat(this.value, 2); } }
                },
                tooltip: { pointFormatter: function(){ return this.category + ': £' + Highcharts.numberFormat(this.y, 2); } },

                series: [{ name: 'Spending', data: totals.map((v, i) => [i, v]), colorByPoint: true }]

            });

            const incomeYearly = {
                segments: yearly.segments.filter(s => parseFloat(s.total) > 0),
                categories: yearly.categories.filter(c => parseFloat(c.total) > 0),
                tags: yearly.tags.filter(t => parseFloat(t.total) > 0)
            };
            const outgoingYearly = {
                segments: yearly.segments.filter(s => parseFloat(s.total) < 0),
                categories: yearly.categories.filter(c => parseFloat(c.total) < 0),
                tags: yearly.tags.filter(t => parseFloat(t.total) < 0)
            };
            const segmentTotals = renderSunburst(outgoingYearly, categories, 'outgoing-sunburst-chart', 'Outgoing Segments, Categories and Tags');
            renderSunburst(incomeYearly, categories, 'income-sunburst-chart', 'Income Segments, Categories and Tags');
            if (segmentTotals.length) {
                renderSegments(segmentTotals);
            }
        }).catch(err => console.error('Graph data load failed', err));
    }

    function renderSunburst(yearly, categories, chartId, chartTitle){

        const makeId = str => (str ? String(str).replace(/\s+/g, '_') : '');
        const categoryMap = {};
        categories.forEach(c => {
            if (c.name) {
                categoryMap[c.name] = c.segment_name || 'Not Segmented';
            }
        });

        const data = [{ id: 'root', name: 'Total' }];
        const segmentIds = {};
        const segmentTotals = {};
        const categoryTotals = {};

        (yearly.categories || []).forEach(c => {
            if (!c.name) return;
            const segName = categoryMap[c.name] || 'Not Segmented';
            let segId = segmentIds[segName];
            if (!segId) {
                segId = 'seg_' + makeId(segName);
                segmentIds[segName] = segId;
                data.push({ id: segId, parent: 'root', name: segName });
            }
            const catId = 'cat_' + makeId(c.name);
            data.push({ id: catId, parent: segId, name: c.name });
            const total = Math.abs(parseFloat(c.total));
            categoryTotals[c.name] = { id: catId, total, segment: segName, fromYearly: true };
            segmentTotals[segName] = (segmentTotals[segName] || 0) + total;
        });

        const tagSums = {};
        (yearly.tags || []).forEach(t => {
            if (!t.name || !t.category) return;
            let catInfo = categoryTotals[t.category];
            let catId;
            if (catInfo) {
                catId = catInfo.id;
            } else {
                const segName = categoryMap[t.category] || 'Not Segmented';
                let segId = segmentIds[segName];
                if (!segId) {
                    segId = 'seg_' + makeId(segName);
                    segmentIds[segName] = segId;
                    data.push({ id: segId, parent: 'root', name: segName });
                }
                catId = 'cat_' + makeId(t.category);
                data.push({ id: catId, parent: segId, name: t.category });
                catInfo = categoryTotals[t.category] = { id: catId, total: 0, segment: segName, fromYearly: false };
            }
            const tagId = 'tag_' + makeId(t.name) + '_' + makeId(t.category);
            const value = Math.abs(parseFloat(t.total));
            data.push({ id: tagId, parent: catId, name: t.name, value });
            tagSums[catId] = (tagSums[catId] || 0) + value;
            if (!catInfo.fromYearly) {
                catInfo.total += value;
                segmentTotals[catInfo.segment] = (segmentTotals[catInfo.segment] || 0) + value;
            }
        });

        Object.values(categoryTotals).forEach(ct => {
            const tagged = tagSums[ct.id] || 0;
            const diff = ct.total - tagged;
            if (Math.abs(diff) > 0.01) {
                data.push({ id: 'tag_other_' + ct.id, parent: ct.id, name: 'Other', value: diff });
            }
        });

        if (yearly.segments) {
            const check = {};
            yearly.segments.forEach(s => {
                if (s.name) {
                    check[s.name] = Math.abs(parseFloat(s.total));
                }
            });
            Object.entries(segmentTotals).forEach(([name, total]) => {
                const reported = check[name] || 0;
                if (Math.abs(reported - total) > 0.01) {
                    console.warn(`Segment total mismatch for ${name}: expected ${reported} calculated ${total}`);
                }
            });
        }

        Highcharts.chart(chartId, {
            series: [{
                type: 'sunburst',
                data: data,
                allowDrillToNode: true,
                cursor: 'pointer',
                dataLabels: {
                    formatter: function(){
                        const sum = (this.point.node && this.point.node.childrenTotal) || this.point.value;
                        return sum !== undefined ? `${this.point.name}: £${Highcharts.numberFormat(sum, 2)}` : this.point.name;
                    },
                    filter: { property: 'innerArcLength', operator: '>', value: 16 }
                },
                // Display a clear hierarchy with segments in the centre
                // followed by categories and tags on the outer rings
                levels: [
                    { level: 1, colorByPoint: true, dataLabels: { rotationMode: 'parallel' } },
                    { level: 2, colorVariation: { key: 'brightness', to: -0.5 } },
                    { level: 3, colorVariation: { key: 'brightness', to: -0.8 } }
                ]
            }],
            title: { text: chartTitle },
            tooltip: {
                pointFormatter: function(){
                    const sum = (this.node && this.node.childrenTotal) || this.value;
                    return '£' + Highcharts.numberFormat(sum, 2);
                }
            }
        });

        return Object.entries(segmentTotals).map(([name, total]) => ({ name, total }));
    }

    function renderSegments(segments){
        const tableEl = document.getElementById('segment-table');
        tableEl.innerHTML = '';
        tailwindTabulator(tableEl, {
            data: segments,
            layout: 'fitDataStretch',
            columns: [
                { title: 'Name', field: 'name', formatter: function(cell){
                    const value = cell.getValue();
                    const badge = createBadge(value, 'bg-yellow-200 text-yellow-800');
                    const link = document.createElement('a');
                    link.href = `search.html?value=${encodeURIComponent(value)}`;
                    link.appendChild(badge);
                    return link;
                } },
                { title: 'Total', field: 'total', formatter: 'money', formatterParams: { symbol: '£', precision: 2 }, hozAlign: 'right', bottomCalc: 'sum', bottomCalcFormatter: 'money', bottomCalcFormatterParams: { symbol: '£', precision: 2 } }
            ]
        });
        Highcharts.chart('segment-chart', {
            colors: gradientColors,
            chart: { type: 'column' },
            title: { text: 'Segment Totals' },
            xAxis: { categories: segments.map(s => s.name) },
            yAxis: { title: { text: 'Amount (£)' }, labels: { formatter: function(){ return '£' + Highcharts.numberFormat(this.value, 2); } } },
            tooltip: { pointFormatter: function(){ return '£' + Highcharts.numberFormat(this.y, 2); } },
            series: [{ name: 'Total', data: segments.map(s => parseFloat(s.total)), colorByPoint: true }]
        });
    }

    document.addEventListener('DOMContentLoaded', () => {
        fetch('../php_backend/public/transaction_months.php')
            .then(resp => resp.json())
            .then(months => {
                const years = Array.from(new Set(months.map(m => m.year))).sort((a,b) => b - a);
                const select = document.getElementById('year-select');
                years.forEach(y => {
                    const opt = document.createElement('option');
                    opt.value = y;
                    opt.textContent = y;
                    select.appendChild(opt);
                });
                const initial = select.value || years[0];
                select.value = initial;
                loadYear(initial);
            });

        document.getElementById('year-select').addEventListener('change', e => loadYear(e.target.value));
    });
    </script>
    <script src="js/overlay.js"></script>
</body>
</html>
